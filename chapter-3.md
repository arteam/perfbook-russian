# Глава 3

## Аппаратное обеспечение и его повадки

Большинство людей имеют интуитивное понимание того, что передача сообщений между системами более дороже, чем выполнение простых вычислений в рамках одной системы. Однако, не всегда ясно, что коммуникация между потоками в рамках одной системы с разделенной памятью может быть тоже вполне дорогой. Эта глава рассматривает цену синхронизации и коммуникации в рамках такой системы. Эти несколько страниц все лишь покажут вершину айсберга дизайна параллельного аппаратного обеспечения с разделенной памятью. Читатели, желающие получить больше деталей, могут начать с последного издания классической книги Хеннесси и Паттерсона [HP95].

**Быстрый вопрос 3.1:**  Зачем программистам параллельных систем учить низкоуровненевые свойства аппартаного обеспечения? Не будет ли проще, лучше, и более обще отстаться на более высоком уровне абстракции?

## 3.1 Обзор

Беззаботные читатели спецификаций компьютерных систем могут прийти к выводу, что производительность процессоров и забег на чистой дороге, как показано на графике 3.1, где победу всегда одерживает быстрейший.

![График 3.1](../master/cartoons/trackmeet.png?raw=true)

График 3.1 Производительность процессоров в забеге

Хотя есть несколько процессорных бенчмарков, которые берут за основу идеал, показанный на графике, реальные программы больше похожы на бег с препятствиями, чем на забег по дорожкам. Это происходит из-за внутренней архитектуры процессоров, которая сильно изменилась за последние несколько десятков лет благодаря закону Мура. Эти изменения показаны в следующих разделах.

### 3.1.1 Конвейерные процессоры

Как работал в начале 1980-х типичный микропроцессор: он выбирал инструкцию, декодировал ее и затем выполнял. В итоге требовалось *как минимум* 3 такта, чтобы обработать одну инструкцию перед переходом к следующей. На контрасте, типичный процессор конца 1990-х - начала 2000-х выполнят много инструкций одновременно, используя глубокий "конвейер" для управления потоком инструкций внутри процессора. Эти современные аппаратные возможности могут сильно улучшить производительность, как показано на графике 3.2.

![График 3.2](../master/cartoons/old_man_and_brat.png?raw=true)

***Новый** : 4.0 Гц тактовая частота, 20 Мб кэша 3 уровня, 20 уровненый конвейер*

***Старый**: Единственный конвейер который мне нужен, это тот, который остудит этого горячего молокососа*

График 3.2 Старый и новый процессор

Достижение полной производительности с процессором, который имеет длинный конвейер, требует высокопредсказуемого потока управления во время программы. Подходящий поток может быть предоставлен, если программа в основном работает в узких циклах. Например, выполняет арифметику на больших матрицах или векторах. В этом слуае процессор корректно предскажет, что ветка в конце цикла будет достигнута почти во всех случаях. В итоге конвейер будет полным и процессор будет работать на полной скорости.

Однако, предположим, что мы имеем либо программу с большим количеством коротких циклов или объектно-ориентированную программу с большим количеством виртуальных объектов, которые могут ссылаться на реальные объекты, которые имеют различные реализации для часто вызываемых методов. В этих случаях сложно или даже невозможно для процессора предсказать какая ветка будет исполнена. Процессор, следовательно, вынужден либо простаивать, ожидая, что поток выполнения продвинется до момента, когда можно точно знать какая ветка будет исполнена, или догадываться. И для программ с непредсказуемым потоком управления - часто догадываться неправильно. Неправильные догадки могут быть очень дорогими, так как процессор вынужден выбросить все результаты инструкций, которые были выполнены спекулятивно. Более того, в независимости от того, простаивает процессор или догадывается, конвейер будет пустым и будет требовать наполнения. Это приведет к простоям, которые могут значительно уменьшить производительность, как ярко показано на графике 3.3. 

![График 3.3](../master/cartoons/pipeline.png?raw=true)

График 3.3 Процессор встречает сброс конвейера

К сожалению, сбросы конвейера не единственные опасности на дорожке с препятствиями, которые современный процессор обязан обойти. Следующий раздел описывает опасности получения данных из памяти.
