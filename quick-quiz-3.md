# Ответы на Быстрые вопросы

## F.3 Аппаратное обеспечение и его повадки

**Быстрый вопрос 3.1:** 

Зачем программистам параллельных систем учить низкоуровненевые свойства аппартаного обеспечения? Не будет ли проще, лучше, и более обще отстаться на более высоком уровне абстракции?

**Ответ:** 

Конечно, можно игнорировать детальные свойства аппаратного обеспечения, но в большинстве случаев - это достаточно глупая вещь. Если вы согласны, что единственная цель параллелизма - увеличение проивзодительности, и вы согласны, что производительность зависит от детальных свойств аппаратого обеспечения, то логически следует, что параллельным программистам необходимо знать по-крайней мере несколько свойств "железа".

Абсолютно такая же ситуация просходит во всех инжереных дисциплинах. Хотели бы вы использовать мост, спроектированный инженером, который не понимает бы свойства материалов, из которых сделан мост? Если нет, почему вы ожидаете, что параллельный программист может разработать достойное параллельное программное обеспечение без хотя бы некоторого понимания "железа", на котором это обеспечение работает?

**Быстрый вопрос 3.2:** 

Какие типы машин разрешали бы атомарные операции над несколькими элементами данных?

**Ответ:**

Один из ответов на этот вопрос, это то, что часто возможно упаковать множество элементов данных в одно машинное слово, с котрым можно работать атомарно.

Более современным был бы ответ, что машина могла бы поддерживать транзакционную память [Lom77]. Однако, такие машины все еще являются объектом исследования. Хотя, в начале 2012 кажется, что протипы таких систем, поддерживающие ограниченное формы аппаратной транзакционной памяти будут коммерчески доступны в течение нескольких лет. Жюри все еще сомневается в применимости программной транзакционной памяти [MMW07, PW07, RHP+07, CBM+08, DFGG11, MS12]. Дополнительную информацию о программной транзакционной памяти можно найти в разделе 16.2.


**Быстрый вопрос 3.3:** 

Действительно ли дизайнеры процессоров сильно уменьшили накладные расходы промахов кэша?

**Ответ:**

К сожалению, не так сильно. В последнее время было некотрое уменьшение при определенном количестве процессоров, но конечность скорости света и атомная структура материи ограничивают возможность дизайнеров уменьшить накладные расходы промаха кэша в больших системах. Раздел 3.3 обсуждает некоторые возможные пути будущего прогресса в этой области.

**Быстрый вопрос 3.4:** 

Это *упрощенная* последовательность событий? Как она вообще может быть более сложной?

**Ответ:**

Эта последовательность игнорирует некоторые возможные сложности, например:

1. Другие процессоры могли бы конкуретно выполнять CAS операцию на той же кэш-линии.

2. Кэш-линия могла бы быть помеченной "на чтение" в кэшах нескольких процессоров. В этом случае, нужно было бы сбрасывать их кэши.

3. Процессор 7 мог бы работать с кэш-линией во время прихода запроса. В этом случае процессор 7 вынужден был бы приостановить запрос, до тех пор, пока не выполнится операция.

4. Процессор 7 мог бы изъять кэш-линию из его кэша(например, чтобы освободить место для других данных). Так что во время прихода запроса, кэш-линия могла бы уже быть на путь в память.

5. В кэш-линии могла бы произойти восставливаемая ошибка. В этом случае она должны была быть исправлена в некоторый момент перед использованием данных.

Механизмы когерентности кэшей производстенного уровня крайне сложны из-за таких предположений.

